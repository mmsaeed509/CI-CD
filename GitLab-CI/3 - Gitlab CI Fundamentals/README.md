# Gitlab CI Fundamentals

### GitLab CI: Caches and Artifacts

#### Caches

Caches in GitLab CI are a mechanism to speed up build times by storing and reusing dependencies or intermediate files between jobs. Caches are typically used to persist data across CI job runs, enhancing efficiency and reducing redundant work.

#### Example:

```yaml
stages:
  - build

job:
  script:
    - restore_cache:
        key: dependency-cache-{{ checksum "Gemfile.lock" }}
    - bundle install --path .bundle
    - save_cache:
        key: dependency-cache-{{ checksum "Gemfile.lock" }}
        paths:
          - .bundle
```

In this example, the `restore_cache` and `save_cache` steps utilize caches to store and retrieve dependencies, such as bundled gems, improving the overall build time.

#### Artifacts

Artifacts are files or directories generated by a CI job that you want to persist and make available for download or reference in subsequent jobs. Unlike caches, artifacts are typically meant for final outputs, build artifacts, or any data that needs to be passed between stages or jobs.

#### Example:

```yaml
stages:
  - build
  - test

build:
  script:
    - make build
  artifacts:
    paths:
      - app/bin/
    expire_in: 1 week

test:
  script:
    - ./app/bin/test
```

Here, the `build` job generates binary artifacts in the `app/bin/` directory, and these artifacts are then made available to the `test` job. The `expire_in` attribute sets a time limit for how long the artifacts should be retained.

#### Cache vs. Artifacts

#### Caches:

- Used for storing dependencies or intermediate files.
- Meant to speed up job execution by reusing stored data.
- Typically scoped to a single job.

#### Artifacts:

- Used for persisting final outputs or build artifacts.
- Can be passed between stages and jobs.
- Meant for sharing data between different parts of the CI/CD pipeline.

Consider choosing between caches and artifacts based on whether you need to optimize job execution times (caches) or pass data between jobs and stages (artifacts).

---

### GitLab CI: Variables

GitLab CI allows you to define and use variables within your CI/CD pipeline, providing flexibility and customization for your jobs.

#### Environment Variables

Environment variables in GitLab CI are key-value pairs that can be used to pass data into CI/CD jobs. They can be defined globally for the entire pipeline or specific to each job.

#### Example:

```yaml
variables:
  DATABASE_URL: "postgres://user:password@localhost/db_name"

stages:
  - test

test_job:
  script:
    - echo $DATABASE_URL
```

In this example, the `DATABASE_URL` environment variable is defined globally and accessed within the `test_job` script.

#### CI/CD Variables

GitLab CI/CD provides predefined variables that you can use in your CI/CD configuration. These variables contain information about the pipeline, repository, and more.

#### Example:

```yaml
stages:
  - deploy

deploy_job:
  script:
    - echo "Deploying to environment: $CI_ENVIRONMENT_NAME"
```

Here, the `$CI_ENVIRONMENT_NAME` variable is a predefined variable that holds the name of the target environment.

#### Secret Variables

For sensitive information like API keys or passwords, GitLab CI allows you to define secret variables. These variables are encrypted and should not be exposed in job logs.

#### Example:

```yaml
stages:
  - deploy

deploy_job:
  script:
    - deploy_script.sh
  variables:
    GITLAB_TOKEN: "$CI_JOB_TOKEN"
    SECRET_API_KEY: "$SECRET_API_KEY"
```

In this example, `$SECRET_API_KEY` is a secret variable, and it is used within the `deploy_job` script securely.

#### Using Variables in Scripts

Variables can be referenced in scripts using the standard syntax, such as `$VARIABLE_NAME` or `${VARIABLE_NAME}`.

#### Example:

```yaml
stages:
  - build

build_job:
  script:
    - echo "Building version $CI_COMMIT_REF_NAME"
```

Here, `$CI_COMMIT_REF_NAME` is a predefined variable used in the script to print the branch name being built.

Variables in GitLab CI provide a powerful way to customize and parameterize your CI/CD configuration, making it more adaptable to different scenarios.

---

### GitLab CI: Triggers

In GitLab CI, triggers allow you to start a pipeline in a project remotely, either manually or automatically, based on events in another project. Triggers are useful for coordinating pipelines across different repositories.

#### Manual Triggers

Manual triggers enable users to start a pipeline manually using the GitLab web interface or API. This can be useful for initiating pipelines on-demand for tasks like deployments or ad-hoc testing.

#### Example:

```yaml
stages:
  - deploy

deploy_job:
  script:
    - deploy_script.sh

manual_deploy:
  script:
    - echo "Manually triggered deployment"
  when: manual
```

In this example, the `manual_deploy` job is set to run manually, allowing users to trigger the deployment job when needed.

#### CI/CD Triggers

CI/CD triggers allow you to start a pipeline in one project when specific events occur in another project. This is useful for coordinating pipelines between related projects.

#### Example:

```yaml
stages:
  - build

build_job:
  script:
    - build_script.sh

trigger_deploy:
  script:
    - echo "Triggering deployment in another project"
  trigger:
    project: "group/another-project"
    branch: "main"
```

Here, the `trigger_deploy` job is set to trigger a pipeline in the "another-project" when the pipeline in the current project (specified by `project`) succeeds on the "main" branch.

#### API Triggers

You can also use GitLab CI triggers through the API. This allows for programmatic initiation of pipelines, enabling integration with external systems or custom workflows.

#### Example:

```bash
curl --request POST \
  --form token=TOKEN \
  --form ref=main \
  https://gitlab.example.com/api/v4/projects/PROJECT_ID/trigger/pipeline
```

This example demonstrates triggering a pipeline in a project using the GitLab API.

Triggers in GitLab CI provide a powerful mechanism for coordinating and automating pipelines across different projects, branches, and environments.

---

### GitLab CI: Merge Requests

GitLab CI provides features for integrating Continuous Integration (CI) into the merge request workflow, allowing for automated testing and validation before code changes are merged into a project.

#### CI/CD Pipelines for Merge Requests

Automated CI/CD pipelines can be triggered specifically for merge requests. This ensures that changes introduced in the merge request branch are tested and validated before merging.

#### Example:

```yaml
stages:
  - test

test_job:
  script:
    - run_tests.sh

rules:
  - exists:
      - $CI_COMMIT_FILE
```

In this example, a `test_job` is defined to run tests on the code changes introduced in the merge request. The `rules` attribute ensures that the job runs only when there are changes to be tested.

#### Pipeline Status in Merge Requests

GitLab displays the status of CI/CD pipelines directly in the merge request. This includes information about whether the pipeline passed, failed, or is still running. It provides a quick overview of the code quality and test results.

#### Merge When Pipeline Succeeds

GitLab allows you to enforce a policy where a merge request can only be merged when its associated CI/CD pipeline succeeds. This ensures that only code that has been successfully tested and validated can be merged into the main branch.

#### Configuration:

Navigate to **Settings > General > Merge Requests** and set "Only allow merge requests to be merged if the pipeline succeeds."

#### Artifacts and Reviews in Merge Requests

Artifacts generated during CI/CD pipelines, such as test reports or build artifacts, can be attached to merge requests. Additionally, code reviews and discussions can take place directly in the merge request interface.

---
